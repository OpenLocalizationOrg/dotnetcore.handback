<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-442b6d0" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4a75310e7db79714fb3239babb81e6d748ded5ae</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\gc-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a38b4251b224d5b4f510747f7ad1fec4190df583</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="new">Garbage Collection</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="new">Garbage Collection</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="new">.NET, .NET Core</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="new">Garbage Collection</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Garbage collection is one of most important features of the .NET managed code platform.</source>
          <target state="new">Garbage collection is one of most important features of the .NET managed code platform.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The garbage collector (GC) manages allocating and releasing memory for you.</source>
          <target state="new">The garbage collector (GC) manages allocating and releasing memory for you.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You do not need to how to allocate and release memory or manage the lifetime of the objects that use that memory.</source>
          <target state="new">You do not need to how to allocate and release memory or manage the lifetime of the objects that use that memory.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>An allocation is made any time you <bpt id="p1">_</bpt>new<ept id="p1">_</ept> an object or a value type is boxed.</source>
          <target state="new">An allocation is made any time you <bpt id="p1">_</bpt>new<ept id="p1">_</ept> an object or a value type is boxed.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Allocations are typically very fast.</source>
          <target state="new">Allocations are typically very fast.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When there isn’t enough memory to allocate an object, the GC must collect and dispose of garbage memory to make memory available for new allocations.</source>
          <target state="new">When there isn’t enough memory to allocate an object, the GC must collect and dispose of garbage memory to make memory available for new allocations.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This process is called “garbage collection”.</source>
          <target state="new">This process is called “garbage collection”.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The garbage collector serves as an automatic memory manager.</source>
          <target state="new">The garbage collector serves as an automatic memory manager.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It provides the following benefits:</source>
          <target state="new">It provides the following benefits:</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Enables you to develop your application without having to free memory.</source>
          <target state="new">Enables you to develop your application without having to free memory.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Allocates objects on the managed heap efficiently.</source>
          <target state="new">Allocates objects on the managed heap efficiently.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</source>
          <target state="new">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</source>
          <target state="new">Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Provides memory safety by making sure that an object cannot use the content of another object.</source>
          <target state="new">Provides memory safety by making sure that an object cannot use the content of another object.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The .NET GC is generational and has 3 generations.</source>
          <target state="new">The .NET GC is generational and has 3 generations.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Each generation has its own heap that it uses for storage of allocated objects.</source>
          <target state="new">Each generation has its own heap that it uses for storage of allocated objects.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>There is a basic principle that most objects are either short lived or long lived.</source>
          <target state="new">There is a basic principle that most objects are either short lived or long lived.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Generation 0 is where objects are first allocated.</source>
          <target state="new">Generation 0 is where objects are first allocated.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Objects often don’t live past the first generation, since they are no longer in use (out of scope) by the time the next garbage collection occurs.</source>
          <target state="new">Objects often don’t live past the first generation, since they are no longer in use (out of scope) by the time the next garbage collection occurs.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Generation 0 is quick to collect because its associated heap is small.</source>
          <target state="new">Generation 0 is quick to collect because its associated heap is small.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Generation 1 is really a second chance space.</source>
          <target state="new">Generation 1 is really a second chance space.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Objects that are short lived but survive the generation 0 collection (often based on coincidental timing) go to generation 1<ph id="ph1">\.</ph> Generation 1 collections are also quick because its associated heap is also small.</source>
          <target state="new">Objects that are short lived but survive the generation 0 collection (often based on coincidental timing) go to generation 1<ph id="ph1">\.</ph> Generation 1 collections are also quick because its associated heap is also small.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The first two heaps remain small because objects are either collected or are promoted to the next generation heap.</source>
          <target state="new">The first two heaps remain small because objects are either collected or are promoted to the next generation heap.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Generation 2 is where all long lived objects are.</source>
          <target state="new">Generation 2 is where all long lived objects are.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The generation 2 heap can grow to be very large, since the objects it contains can survive a long time and there is no generation 3 heap to further promote objects.</source>
          <target state="new">The generation 2 heap can grow to be very large, since the objects it contains can survive a long time and there is no generation 3 heap to further promote objects.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The GC has has an additional heap for large objects called the Large Object Heap (LOH).</source>
          <target state="new">The GC has has an additional heap for large objects called the Large Object Heap (LOH).</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>It is reserved for objects that are 85,000 bytes or greater.</source>
          <target state="new">It is reserved for objects that are 85,000 bytes or greater.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>A byte array (Byte[]) with 85k elements would be an example of a large object.</source>
          <target state="new">A byte array (Byte[]) with 85k elements would be an example of a large object.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Large objects are not allocated to the generational heaps but are allocated directly to the LOH.</source>
          <target state="new">Large objects are not allocated to the generational heaps but are allocated directly to the LOH.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Generation 2 and LOH collections can take noticeable time for programs that have run for a long time or operate over large amounts of data.</source>
          <target state="new">Generation 2 and LOH collections can take noticeable time for programs that have run for a long time or operate over large amounts of data.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Large server programs are known to have heaps in the 10s of GBs.</source>
          <target state="new">Large server programs are known to have heaps in the 10s of GBs.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The GC employs a variety of techniques to reduce the amount of time that it blocks program execution.</source>
          <target state="new">The GC employs a variety of techniques to reduce the amount of time that it blocks program execution.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The primary approach is to do as much garbage collection work as possible on a background thread in a way that does not interfere with program execution.</source>
          <target state="new">The primary approach is to do as much garbage collection work as possible on a background thread in a way that does not interfere with program execution.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The GC also exposes a few ways for developers to influence its behavior, which can be quite useful to improve performance.</source>
          <target state="new">The GC also exposes a few ways for developers to influence its behavior, which can be quite useful to improve performance.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Garbage Collection<ept id="p1">](http://msdn.microsoft.com/library/0xy59wtx.aspx)</ept> on MSDN.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>Garbage Collection<ept id="p1">](http://msdn.microsoft.com/library/0xy59wtx.aspx)</ept> on MSDN.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>