<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-442b6d0" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">52c79102bf03cb019e65c7e7b2987329ae3bc19a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\porting\libraries.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c7f1df7fbf93127ae4dd4e29d4f51a91f7312559</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Porting to .NET Core - Libraries</source>
          <target state="new">Porting to .NET Core - Libraries</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Porting to .NET Core - Libraries</source>
          <target state="new">Porting to .NET Core - Libraries</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="new">.NET, .NET Core</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Porting to .NET Core - Libraries</source>
          <target state="new">Porting to .NET Core - Libraries</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>With the release of .NET Core 1.0, there is an opportunity to port existing library code so that it can run cross-platform.</source>
          <target state="new">With the release of .NET Core 1.0, there is an opportunity to port existing library code so that it can run cross-platform.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This article discusses the .NET Standard Library, unavailable technologies, how to account for the smaller number of APIs available on .NET Core 1.0, how to use the tooling that ships with .NET Core SDK Preview 2, and recommended approaches to porting your code.</source>
          <target state="new">This article discusses the .NET Standard Library, unavailable technologies, how to account for the smaller number of APIs available on .NET Core 1.0, how to use the tooling that ships with .NET Core SDK Preview 2, and recommended approaches to porting your code.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Porting is a task that may take time, especially if you have a large codebase.</source>
          <target state="new">Porting is a task that may take time, especially if you have a large codebase.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You should also be prepared to adapt the guidance here as needed to best fit your code.</source>
          <target state="new">You should also be prepared to adapt the guidance here as needed to best fit your code.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Every codebase is different, so this article attempts to frame things in a flexible way, but you may find yourself needing to diverge from the prescribed guidance.</source>
          <target state="new">Every codebase is different, so this article attempts to frame things in a flexible way, but you may find yourself needing to diverge from the prescribed guidance.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="new">Prerequisites</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This article assumes you are using Visual Studio 2015 or later on Windows.</source>
          <target state="new">This article assumes you are using Visual Studio 2015 or later on Windows.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The bits required for building .NET Core code are not available on previous versions of Visual Studio.</source>
          <target state="new">The bits required for building .NET Core code are not available on previous versions of Visual Studio.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This article also assumes that you understand the <bpt id="p1">[</bpt>recommended porting process<ept id="p1">](index.md)</ept> and that you have resolved any issues with <bpt id="p2">[</bpt>third-party dependencies<ept id="p2">](third-party-deps.md)</ept>.</source>
          <target state="new">This article also assumes that you understand the <bpt id="p1">[</bpt>recommended porting process<ept id="p1">](index.md)</ept> and that you have resolved any issues with <bpt id="p2">[</bpt>third-party dependencies<ept id="p2">](third-party-deps.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Targeting the .NET Standard Library</source>
          <target state="new">Targeting the .NET Standard Library</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The best way to build a cross-platform library for .NET Core is to target the <bpt id="p1">[</bpt>.NET Standard Library<ept id="p1">](../../standard/library.md)</ept>.</source>
          <target state="new">The best way to build a cross-platform library for .NET Core is to target the <bpt id="p1">[</bpt>.NET Standard Library<ept id="p1">](../../standard/library.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The .NET Standard Library is the formal specification of .NET APIs that are intended to be available on all .NET runtimes.</source>
          <target state="new">The .NET Standard Library is the formal specification of .NET APIs that are intended to be available on all .NET runtimes.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>It is supported by the .NET Core runtime.</source>
          <target state="new">It is supported by the .NET Core runtime.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>What this means is that you'll have to make a tradeoff between APIs you can use and platforms you can support, and pick the version of the .NET Platform Standard that best suits the tradeoff you wish to make.</source>
          <target state="new">What this means is that you'll have to make a tradeoff between APIs you can use and platforms you can support, and pick the version of the .NET Platform Standard that best suits the tradeoff you wish to make.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>As of right now, there are 7 different versions to consider: .NET Standard 1.0 through 1.6.</source>
          <target state="new">As of right now, there are 7 different versions to consider: .NET Standard 1.0 through 1.6.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>If you pick a higher version, you get access to more APIs at the cost of running on fewer targets.</source>
          <target state="new">If you pick a higher version, you get access to more APIs at the cost of running on fewer targets.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you pick a lower version, your code can run on more targets but at the cost of fewer APIs available to you.</source>
          <target state="new">If you pick a lower version, your code can run on more targets but at the cost of fewer APIs available to you.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For your convenience, here is a matrix of each .NET Standard version and each specific area it runs on:</source>
          <target state="new">For your convenience, here is a matrix of each .NET Standard version and each specific area it runs on:</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Platform Name</source>
          <target state="new">Platform Name</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="new">Alias</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>.NET Standard</source>
          <target state="new">.NET Standard</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>netstandard</source>
          <target state="new">netstandard</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>1.0</source>
          <target state="new">1.0</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>1.1</source>
          <target state="new">1.1</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>1.2</source>
          <target state="new">1.2</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>1.3</source>
          <target state="new">1.3</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>1.4</source>
          <target state="new">1.4</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>1.5</source>
          <target state="new">1.5</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>1.6</source>
          <target state="new">1.6</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>.NET Core</source>
          <target state="new">.NET Core</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>netcoreapp</source>
          <target state="new">netcoreapp</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>1.0</source>
          <target state="new">1.0</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>.NET Framework</source>
          <target state="new">.NET Framework</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>net</source>
          <target state="new">net</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>4.5</source>
          <target state="new">4.5</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>4.5.1</source>
          <target state="new">4.5.1</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>4.6</source>
          <target state="new">4.6</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>4.6.1</source>
          <target state="new">4.6.1</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>4.6.2</source>
          <target state="new">4.6.2</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>4.6.3</source>
          <target state="new">4.6.3</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Mono/Xamarin Platforms</source>
          <target state="new">Mono/Xamarin Platforms</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Universal Windows Platform</source>
          <target state="new">Universal Windows Platform</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>uap</source>
          <target state="new">uap</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>10.0</source>
          <target state="new">10.0</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="new">Windows</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>win</source>
          <target state="new">win</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>8.0</source>
          <target state="new">8.0</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>8.1</source>
          <target state="new">8.1</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Windows Phone</source>
          <target state="new">Windows Phone</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>wpa</source>
          <target state="new">wpa</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>8.1</source>
          <target state="new">8.1</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Windows Phone Silverlight</source>
          <target state="new">Windows Phone Silverlight</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>wp</source>
          <target state="new">wp</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>8.0</source>
          <target state="new">8.0</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A key thing to understand is that <bpt id="p1">**</bpt>a project targeting a lower version cannot reference a project targeting a higher version<ept id="p1">**</ept>.</source>
          <target state="new">A key thing to understand is that <bpt id="p1">**</bpt>a project targeting a lower version cannot reference a project targeting a higher version<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, a project targeting the .NET Platform Standard version 1.2 cannot reference projects that target .NET Platform Standard version 1.3 or higher.</source>
          <target state="new">For example, a project targeting the .NET Platform Standard version 1.2 cannot reference projects that target .NET Platform Standard version 1.3 or higher.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Projects <bpt id="p1">**</bpt>can<ept id="p1">**</ept> reference lower versions, though, so a project targeting .NET Platform Standard 1.3 can reference a project targeting .NET Platform Standard 1.2 or lower.</source>
          <target state="new">Projects <bpt id="p1">**</bpt>can<ept id="p1">**</ept> reference lower versions, though, so a project targeting .NET Platform Standard 1.3 can reference a project targeting .NET Platform Standard 1.2 or lower.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>It's recommended that you pick the lowest possible .NET Standard version and use that throughout your project.</source>
          <target state="new">It's recommended that you pick the lowest possible .NET Standard version and use that throughout your project.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Read more in <bpt id="p1">[</bpt>.NET Platform Standard Library<ept id="p1">](../../standard/library.md)</ept>.</source>
          <target state="new">Read more in <bpt id="p1">[</bpt>.NET Platform Standard Library<ept id="p1">](../../standard/library.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Key Technologies Not Yet Available on the .NET Standard or .NET Core</source>
          <target state="new">Key Technologies Not Yet Available on the .NET Standard or .NET Core</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You may be using some technologies available for the .NET Framework that are not currently available for .NET Core.</source>
          <target state="new">You may be using some technologies available for the .NET Framework that are not currently available for .NET Core.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Each of the following sub-sections corresponds to one of those technologies.</source>
          <target state="new">Each of the following sub-sections corresponds to one of those technologies.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Alternative options are listed if it is feasible for you to adopt them.</source>
          <target state="new">Alternative options are listed if it is feasible for you to adopt them.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>App Domains</source>
          <target state="new">App Domains</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>AppDomains can be used for different purposes on the .NET Framework.</source>
          <target state="new">AppDomains can be used for different purposes on the .NET Framework.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For code isolation, we recommend separate processes and/or containers as an alternative.</source>
          <target state="new">For code isolation, we recommend separate processes and/or containers as an alternative.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For dynamic loading of assemblies, we recommend the new  @System.Runtime.Loader.AssemblyLoadContext class.</source>
          <target state="new">For dynamic loading of assemblies, we recommend the new  @System.Runtime.Loader.AssemblyLoadContext class.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Remoting</source>
          <target state="new">Remoting</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For communication across processes, inter-process communication (IPC) mechanisms can be used as an alternative to Remoting, such as <bpt id="p1">[</bpt>Pipes<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/system.io.pipes)</ept> or <bpt id="p2">[</bpt>Memory Mapped Files<ept id="p2">](https://docs.microsoft.com/dotnet/core/api/system.io.memorymappedfiles.memorymappedfile)</ept>.</source>
          <target state="new">For communication across processes, inter-process communication (IPC) mechanisms can be used as an alternative to Remoting, such as <bpt id="p1">[</bpt>Pipes<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/system.io.pipes)</ept> or <bpt id="p2">[</bpt>Memory Mapped Files<ept id="p2">](https://docs.microsoft.com/dotnet/core/api/system.io.memorymappedfiles.memorymappedfile)</ept>.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Across machines, you can use a network based solution as an alternative, preferably a low-overhead plain text protocol such as HTTP.</source>
          <target state="new">Across machines, you can use a network based solution as an alternative, preferably a low-overhead plain text protocol such as HTTP.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>KestrelHttpServer<ept id="p1">](https://github.com/aspnet/KestrelHttpServer)</ept>, the web server used by ASP.NET Core, is an option here.</source>
          <target state="new"><bpt id="p1">[</bpt>KestrelHttpServer<ept id="p1">](https://github.com/aspnet/KestrelHttpServer)</ept>, the web server used by ASP.NET Core, is an option here.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Remote proxy generation via <bpt id="p1">[</bpt>Castle.Core<ept id="p1">](https://github.com/castleproject/Core)</ept> is also an option to consider.</source>
          <target state="new">Remote proxy generation via <bpt id="p1">[</bpt>Castle.Core<ept id="p1">](https://github.com/castleproject/Core)</ept> is also an option to consider.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Binary Serialization</source>
          <target state="new">Binary Serialization</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>As an alternative to Binary Serialization, there are multiple different serialization technologies to choose.</source>
          <target state="new">As an alternative to Binary Serialization, there are multiple different serialization technologies to choose.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>You should choose one that fits your goals for formatting and footprint.</source>
          <target state="new">You should choose one that fits your goals for formatting and footprint.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Popular choices include:</source>
          <target state="new">Popular choices include:</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>JSON.NET<ept id="p1">](http://www.newtonsoft.com/json)</ept> for JSON</source>
          <target state="new"><bpt id="p1">[</bpt>JSON.NET<ept id="p1">](http://www.newtonsoft.com/json)</ept> for JSON</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>@System.Runtime.Serialization.DataContractSerializer for both XML and JSON</source>
          <target state="new">@System.Runtime.Serialization.DataContractSerializer for both XML and JSON</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>@System.Xml.Serialization.XmlSerializer for XML</source>
          <target state="new">@System.Xml.Serialization.XmlSerializer for XML</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>protobuf-net<ept id="p1">](https://github.com/mgravell/protobuf-net)</ept> for Protocol Buffers</source>
          <target state="new"><bpt id="p1">[</bpt>protobuf-net<ept id="p1">](https://github.com/mgravell/protobuf-net)</ept> for Protocol Buffers</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Refer to the linked resources to learn about their benefits and choose the ones for your needs.</source>
          <target state="new">Refer to the linked resources to learn about their benefits and choose the ones for your needs.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>There are many other serialization formats and technologies out there, many of which are open source.</source>
          <target state="new">There are many other serialization formats and technologies out there, many of which are open source.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Sandboxes</source>
          <target state="new">Sandboxes</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>As an alternative to Sandboxing, you can use operating system provided security boundaries, such as user accounts for running processes with the least set of privileges.</source>
          <target state="new">As an alternative to Sandboxing, you can use operating system provided security boundaries, such as user accounts for running processes with the least set of privileges.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Overview of</source>
          <target state="new">Overview of</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>project.json project model<ept id="p1">](../tools/project-json.md)</ept> is a project model that ships with .NET Core SDK 1.0 Preview 2.</source>
          <target state="new">The <bpt id="p1">[</bpt>project.json project model<ept id="p1">](../tools/project-json.md)</ept> is a project model that ships with .NET Core SDK 1.0 Preview 2.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>It offers some benefits you may wish to take advantage of today:</source>
          <target state="new">It offers some benefits you may wish to take advantage of today:</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Simple multitargeting where target-specific assemblies can be generated from a single build.</source>
          <target state="new">Simple multitargeting where target-specific assemblies can be generated from a single build.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The ability to easily generate a NuGet package with a build of the project.</source>
          <target state="new">The ability to easily generate a NuGet package with a build of the project.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>No need to list files in your project file.</source>
          <target state="new">No need to list files in your project file.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Unification of NuGet package dependencies and project-to-project dependencies.</source>
          <target state="new">Unification of NuGet package dependencies and project-to-project dependencies.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>While <ph id="ph1">`project.json`</ph> is eventually going to be deprecated, it can be used to build libraries on the .NET Standard today.</source>
          <target state="new">While <ph id="ph1">`project.json`</ph> is eventually going to be deprecated, it can be used to build libraries on the .NET Standard today.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The Project File:</source>
          <target state="new">The Project File:</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>.NET Core projects are defined by a directory containing a <ph id="ph1">`project.json`</ph> file.</source>
          <target state="new">.NET Core projects are defined by a directory containing a <ph id="ph1">`project.json`</ph> file.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This file is where aspects of the project are declared, such as package dependencies, compiler configuration, runtime configuration, and more.</source>
          <target state="new">This file is where aspects of the project are declared, such as package dependencies, compiler configuration, runtime configuration, and more.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`dotnet restore`</ph> command reads this project file, restores all dependencies of the project, and generates a <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="new">The <ph id="ph1">`dotnet restore`</ph> command reads this project file, restores all dependencies of the project, and generates a <ph id="ph2">`project.lock.json`</ph> file.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This file contains all the necessary information the build system needs to build the project.</source>
          <target state="new">This file contains all the necessary information the build system needs to build the project.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>To learn more about the <ph id="ph1">`project.json`</ph> file, read the <bpt id="p1">[</bpt>project.json reference<ept id="p1">](../tools/project-json.md)</ept>.</source>
          <target state="new">To learn more about the <ph id="ph1">`project.json`</ph> file, read the <bpt id="p1">[</bpt>project.json reference<ept id="p1">](../tools/project-json.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The Solution File:</source>
          <target state="new">The Solution File:</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`global.json`</ph> file is an optional file to include in a solution which contains multiple projects.</source>
          <target state="new">The <ph id="ph1">`global.json`</ph> file is an optional file to include in a solution which contains multiple projects.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>It typically resides in the root directory of a set of projects.</source>
          <target state="new">It typically resides in the root directory of a set of projects.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It can be used to inform the build system of different subdirectories which can contain projects.</source>
          <target state="new">It can be used to inform the build system of different subdirectories which can contain projects.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This is for larger systems composed of several projects.</source>
          <target state="new">This is for larger systems composed of several projects.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>For example, you can organize your code into top-level <ph id="ph1">`/src`</ph> and <ph id="ph2">`/test`</ph> folder as such:</source>
          <target state="new">For example, you can organize your code into top-level <ph id="ph1">`/src`</ph> and <ph id="ph2">`/test`</ph> folder as such:</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>You can then have multiple <ph id="ph1">`project.json`</ph> files under their own sub-folders inside <ph id="ph2">`/src`</ph> and <ph id="ph3">`/test`</ph>.</source>
          <target state="new">You can then have multiple <ph id="ph1">`project.json`</ph> files under their own sub-folders inside <ph id="ph2">`/src`</ph> and <ph id="ph3">`/test`</ph>.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>How to Multitarget with</source>
          <target state="new">How to Multitarget with</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Many libraries multitarget to have as wide of a reach as possible.</source>
          <target state="new">Many libraries multitarget to have as wide of a reach as possible.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>With .NET Core, multitargeting is a "first class citizen", meaning that you can easily generate platform-specific assemblies with a single build.</source>
          <target state="new">With .NET Core, multitargeting is a "first class citizen", meaning that you can easily generate platform-specific assemblies with a single build.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Multitargeting is as simple as adding the correct Target Framework Moniker (TFM) to your <ph id="ph1">`project.json`</ph> file, using the correct dependencies for each target (<ph id="ph2">`dependencies`</ph> for .NET Core and <ph id="ph3">`frameworkAssemblies`</ph> for .NET Framework), and potentially using <ph id="ph4">`#if`</ph> directives to conditionally compile the source code for platform-specific API usage.</source>
          <target state="new">Multitargeting is as simple as adding the correct Target Framework Moniker (TFM) to your <ph id="ph1">`project.json`</ph> file, using the correct dependencies for each target (<ph id="ph2">`dependencies`</ph> for .NET Core and <ph id="ph3">`frameworkAssemblies`</ph> for .NET Framework), and potentially using <ph id="ph4">`#if`</ph> directives to conditionally compile the source code for platform-specific API usage.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>For example, imagine you are building a library where you wanted to perform some network operations, and you wanted that library to run on all .NET Framework versions, a Portable Class Library (PCL) Profile, and .NET Core.</source>
          <target state="new">For example, imagine you are building a library where you wanted to perform some network operations, and you wanted that library to run on all .NET Framework versions, a Portable Class Library (PCL) Profile, and .NET Core.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For .NET Core and .NET Framework 4.5+ targets, you may use <ph id="ph1">`System.Net.Http`</ph> library and <ph id="ph2">`async`/`await`</ph>.</source>
          <target state="new">For .NET Core and .NET Framework 4.5+ targets, you may use <ph id="ph1">`System.Net.Http`</ph> library and <ph id="ph2">`async`/`await`</ph>.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>However, for earlier versions of .NET Framework, those APIs aren't available.</source>
          <target state="new">However, for earlier versions of .NET Framework, those APIs aren't available.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Here's a sample <ph id="ph1">`frameworks`</ph> section for a <ph id="ph2">`project.json`</ph> that targets the .NET Framework versions 2.0, 3.5, 4.0, 4.5, and .NET Standard 1.6:</source>
          <target state="new">Here's a sample <ph id="ph1">`frameworks`</ph> section for a <ph id="ph2">`project.json`</ph> that targets the .NET Framework versions 2.0, 3.5, 4.0, 4.5, and .NET Standard 1.6:</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Note that PCL targets are special: they require you to specify a build definition for the compiler to recognize, and they require you to specify all of the assemblies you use, including <ph id="ph1">`mscorlib`</ph>.</source>
          <target state="new">Note that PCL targets are special: they require you to specify a build definition for the compiler to recognize, and they require you to specify all of the assemblies you use, including <ph id="ph1">`mscorlib`</ph>.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Your source code could then use the dependencies like this:</source>
          <target state="new">Your source code could then use the dependencies like this:</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Note that all of the .NET Framework and .NET Standard targets have names recognized by the compiler:</source>
          <target state="new">Note that all of the .NET Framework and .NET Standard targets have names recognized by the compiler:</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>As mentioned above, if you are targeting a PCL, then you will have to specify a build definition for the compiler to understand.</source>
          <target state="new">As mentioned above, if you are targeting a PCL, then you will have to specify a build definition for the compiler to understand.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>There is no default definition that the compiler can use.</source>
          <target state="new">There is no default definition that the compiler can use.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Using <ph id="ph1">`project.json`</ph> in Visual Studio</source>
          <target state="new">Using <ph id="ph1">`project.json`</ph> in Visual Studio</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>You have two options for using <ph id="ph1">`project.json`</ph> in Visual Studio:</source>
          <target state="new">You have two options for using <ph id="ph1">`project.json`</ph> in Visual Studio:</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A new xproj project type.</source>
          <target state="new">A new xproj project type.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>A retargeted PCL project which supports .NET Standard.</source>
          <target state="new">A retargeted PCL project which supports .NET Standard.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>There are different benefits and drawbacks for each.</source>
          <target state="new">There are different benefits and drawbacks for each.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>When to Pick an Xproj Project</source>
          <target state="new">When to Pick an Xproj Project</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The new Xproj project system in Visual Studio utilizes the capabilities of the <ph id="ph1">`project.json`</ph>-based project model to offer two major features over existing project types: seamless multitargeting by building multiple assemblies and the ability to directly generate a NuGet package on build.</source>
          <target state="new">The new Xproj project system in Visual Studio utilizes the capabilities of the <ph id="ph1">`project.json`</ph>-based project model to offer two major features over existing project types: seamless multitargeting by building multiple assemblies and the ability to directly generate a NuGet package on build.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>However, it comes at the cost of lacking certain features you may use, such as:</source>
          <target state="new">However, it comes at the cost of lacking certain features you may use, such as:</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Support for F# or Visual Basic</source>
          <target state="new">Support for F# or Visual Basic</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Generating satellite assemblies with localized resource strings</source>
          <target state="new">Generating satellite assemblies with localized resource strings</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Directly referencing a <ph id="ph1">`.dll`</ph> file on the filesystem</source>
          <target state="new">Directly referencing a <ph id="ph1">`.dll`</ph> file on the filesystem</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The ability to reference a csproj-based project in the Reference Manager (depending on the <ph id="ph1">`.dll`</ph> file directly is supported, though)</source>
          <target state="new">The ability to reference a csproj-based project in the Reference Manager (depending on the <ph id="ph1">`.dll`</ph> file directly is supported, though)</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If your project needs are relatively minimal and you can take advantage of the new features of xproj, you should pick it as your project system.</source>
          <target state="new">If your project needs are relatively minimal and you can take advantage of the new features of xproj, you should pick it as your project system.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>This can be done in Visual Studio as such:</source>
          <target state="new">This can be done in Visual Studio as such:</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Ensure you are using Visual Studio 2015 or later.</source>
          <target state="new">Ensure you are using Visual Studio 2015 or later.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Select File | New Project.</source>
          <target state="new">Select File | New Project.</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Select ".NET Core" under Visual C#.</source>
          <target state="new">Select ".NET Core" under Visual C#.</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Select the "Class Library (.NET Core)" template.</source>
          <target state="new">Select the "Class Library (.NET Core)" template.</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When to Pick a PCL project</source>
          <target state="new">When to Pick a PCL project</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>You can target .NET Core with the traditional project system in Visual Studio, by creating a Portable Class Library (PCL) and selecting ".NET Core" in the project configuration dialog.</source>
          <target state="new">You can target .NET Core with the traditional project system in Visual Studio, by creating a Portable Class Library (PCL) and selecting ".NET Core" in the project configuration dialog.</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Then you'll need to retarget the project to be based on the .NET Standard:</source>
          <target state="new">Then you'll need to retarget the project to be based on the .NET Standard:</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Right-click on the project file in Visual Studio and select Properties.</source>
          <target state="new">Right-click on the project file in Visual Studio and select Properties.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Under Build, select "Convert to .NET Standard".</source>
          <target state="new">Under Build, select "Convert to .NET Standard".</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If you have more advanced project system needs, this should be your choice.</source>
          <target state="new">If you have more advanced project system needs, this should be your choice.</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Note that if you wish to multitarget by generating platform-specific assemblies like with the <ph id="ph1">`xproj`</ph> project system, you'll need to create a "Bait and Switch" PCL, as described in <bpt id="p1">[</bpt>How to Make Portable Class Libraries Work for You<ept id="p1">](https://blogs.msdn.microsoft.com/dsplaisted/2012/08/27/how-to-make-portable-class-libraries-work-for-you/)</ept>.</source>
          <target state="new">Note that if you wish to multitarget by generating platform-specific assemblies like with the <ph id="ph1">`xproj`</ph> project system, you'll need to create a "Bait and Switch" PCL, as described in <bpt id="p1">[</bpt>How to Make Portable Class Libraries Work for You<ept id="p1">](https://blogs.msdn.microsoft.com/dsplaisted/2012/08/27/how-to-make-portable-class-libraries-work-for-you/)</ept>.</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Retargeting your .NET Framework Code to .NET Framework 4.6.1</source>
          <target state="new">Retargeting your .NET Framework Code to .NET Framework 4.6.1</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If your code is not targeting .NET Framework 4.6.1, it's recommended that you retarget.</source>
          <target state="new">If your code is not targeting .NET Framework 4.6.1, it's recommended that you retarget.</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>This ensures that you can use the latest API alternatives for cases where the .NET Standard can't support existing APIs.</source>
          <target state="new">This ensures that you can use the latest API alternatives for cases where the .NET Standard can't support existing APIs.</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>For each of your projects in Visual Studio you wish to port, do the following:</source>
          <target state="new">For each of your projects in Visual Studio you wish to port, do the following:</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Right-click on the project and select Properties</source>
          <target state="new">Right-click on the project and select Properties</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>In the "Target Framework" dropdown, select ".NET Framework 4.6.2".</source>
          <target state="new">In the "Target Framework" dropdown, select ".NET Framework 4.6.2".</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Recompile your projects.</source>
          <target state="new">Recompile your projects.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="new">And that's it!</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Because your projects now target .NET Framework 4.6.2, you can use that version of .NET Framework as your base for porting code.</source>
          <target state="new">Because your projects now target .NET Framework 4.6.2, you can use that version of .NET Framework as your base for porting code.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Determining the Portability of Your Code</source>
          <target state="new">Determining the Portability of Your Code</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The next step is to run the API Portability Analyzer (ApiPort) to generate a portability report that you can begin to analyze.</source>
          <target state="new">The next step is to run the API Portability Analyzer (ApiPort) to generate a portability report that you can begin to analyze.</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>You'll need to make sure you understand the <bpt id="p1">[</bpt>API Portability tool (ApiPort)<ept id="p1">](https://github.com/Microsoft/dotnet-apiport/blob/master/docs/HowTo/Introduction.md)</ept> and can generate portability reports for targeting .NET Core.</source>
          <target state="new">You'll need to make sure you understand the <bpt id="p1">[</bpt>API Portability tool (ApiPort)<ept id="p1">](https://github.com/Microsoft/dotnet-apiport/blob/master/docs/HowTo/Introduction.md)</ept> and can generate portability reports for targeting .NET Core.</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>How you do this will likely vary based on your needs and personal tastes.</source>
          <target state="new">How you do this will likely vary based on your needs and personal tastes.</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>What follows are a few different approaches - you may find yourself mixing each approach depending on how your code is structured.</source>
          <target state="new">What follows are a few different approaches - you may find yourself mixing each approach depending on how your code is structured.</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Dealing Primarily with the Compiler</source>
          <target state="new">Dealing Primarily with the Compiler</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This approach may be the best for small projects or projects which don't use many .NET Framework APIs.</source>
          <target state="new">This approach may be the best for small projects or projects which don't use many .NET Framework APIs.</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The approach is very simple:</source>
          <target state="new">The approach is very simple:</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Optionally run ApiPort on your project.</source>
          <target state="new">Optionally run ApiPort on your project.</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>If ApiPort was ran, take a quick glance at the report.</source>
          <target state="new">If ApiPort was ran, take a quick glance at the report.</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Copy all of your code over into a new .NET Core project.</source>
          <target state="new">Copy all of your code over into a new .NET Core project.</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Work out compiler errors until it compiles, referring to the portability report if needed.</source>
          <target state="new">Work out compiler errors until it compiles, referring to the portability report if needed.</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Repeat as needed.</source>
          <target state="new">Repeat as needed.</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Although this approach is very unstructured, the code-focused approach can lead to resolving any issues quickly, and may be the best approach for smaller projects or libraries.</source>
          <target state="new">Although this approach is very unstructured, the code-focused approach can lead to resolving any issues quickly, and may be the best approach for smaller projects or libraries.</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>A project that contains only data models may be an ideal candidate here.</source>
          <target state="new">A project that contains only data models may be an ideal candidate here.</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Staying on the .NET Framework until Portability Issues are Resolved</source>
          <target state="new">Staying on the .NET Framework until Portability Issues are Resolved</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>This approach may be the best if you prefer to have code that compiles during the entire process.</source>
          <target state="new">This approach may be the best if you prefer to have code that compiles during the entire process.</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The approach is as follows:</source>
          <target state="new">The approach is as follows:</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Run ApiPort on a project.</source>
          <target state="new">Run ApiPort on a project.</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Address issues by using different APIs which are portable.</source>
          <target state="new">Address issues by using different APIs which are portable.</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Keep note of any areas where you can't use a direct alternative.</source>
          <target state="new">Keep note of any areas where you can't use a direct alternative.</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Repeat steps 1-3 for all projects you're porting until you're confident each is ready to be copied over into a .NET Core project.</source>
          <target state="new">Repeat steps 1-3 for all projects you're porting until you're confident each is ready to be copied over into a .NET Core project.</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Copy the code into a new .NET Core projects.</source>
          <target state="new">Copy the code into a new .NET Core projects.</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Work out any issues that you've kept note of.</source>
          <target state="new">Work out any issues that you've kept note of.</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>This careful approach is more structured than simply working out compiler errors, but it is still relatively code-focused and has the benefit of always having code that can compile.</source>
          <target state="new">This careful approach is more structured than simply working out compiler errors, but it is still relatively code-focused and has the benefit of always having code that can compile.</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The way you resolve certain issues that couldn't be addressed by just using another API can vary greatly.</source>
          <target state="new">The way you resolve certain issues that couldn't be addressed by just using another API can vary greatly.</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>You may find that you need to develop a more comprehensive plan for certain projects, which is covered as the next approach.</source>
          <target state="new">You may find that you need to develop a more comprehensive plan for certain projects, which is covered as the next approach.</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Developing a Comprehensive Plan of Attack</source>
          <target state="new">Developing a Comprehensive Plan of Attack</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>This approach may be best for larger and more complex projects, where restructuring of code or rewriting certain areas may be necessary to support .NET Core.</source>
          <target state="new">This approach may be best for larger and more complex projects, where restructuring of code or rewriting certain areas may be necessary to support .NET Core.</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The approach is as follows:</source>
          <target state="new">The approach is as follows:</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Run ApiPort on a project.</source>
          <target state="new">Run ApiPort on a project.</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Understand where in your code each non-portable type is being used and how that affects overall portability.</source>
          <target state="new">Understand where in your code each non-portable type is being used and how that affects overall portability.</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>a.</source>
          <target state="new">a.</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Understand the nature of those types.</source>
          <target state="new">Understand the nature of those types.</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Are they small in number, but used frequently?</source>
          <target state="new">Are they small in number, but used frequently?</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Are they large in number, but used infrequently?</source>
          <target state="new">Are they large in number, but used infrequently?</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Is their use concentrated, or is it spread throughout your code?</source>
          <target state="new">Is their use concentrated, or is it spread throughout your code?</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>b.</source>
          <target state="new">b.</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Is it easy to isolate code that isn't portable so you can deal with it more easily?</source>
          <target state="new">Is it easy to isolate code that isn't portable so you can deal with it more easily?</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>c.</source>
          <target state="new">c.</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Would you need to refactor your code?</source>
          <target state="new">Would you need to refactor your code?</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>d.</source>
          <target state="new">d.</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>For those types which aren't portable, are there alternative APIs that accomplish the same task?</source>
          <target state="new">For those types which aren't portable, are there alternative APIs that accomplish the same task?</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>For example, if you're using the <ph id="ph1">`WebClient`</ph> class, you may be able to use the <ph id="ph2">`HttpClient`</ph> class instead.</source>
          <target state="new">For example, if you're using the <ph id="ph1">`WebClient`</ph> class, you may be able to use the <ph id="ph2">`HttpClient`</ph> class instead.</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>e.</source>
          <target state="new">e.</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Are there different portable APIs you can use to accomplish a task, even if it's not a drop-in replacement?</source>
          <target state="new">Are there different portable APIs you can use to accomplish a task, even if it's not a drop-in replacement?</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>For example, if you're using <ph id="ph1">`XmlSchema`</ph> to help parse XML, but you don't require XML schema discovery, you could use <ph id="ph2">`System.Linq.Xml`</ph> APIs and hand-parse the data.</source>
          <target state="new">For example, if you're using <ph id="ph1">`XmlSchema`</ph> to help parse XML, but you don't require XML schema discovery, you could use <ph id="ph2">`System.Linq.Xml`</ph> APIs and hand-parse the data.</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>If you have assemblies that are difficult to port, is it worth leaving them on .NET Framework for now?</source>
          <target state="new">If you have assemblies that are difficult to port, is it worth leaving them on .NET Framework for now?</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Here are some things to consider:</source>
          <target state="new">Here are some things to consider:</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>a.</source>
          <target state="new">a.</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>You may have some functionality in your library that's incompatible with .NET Core because it relies too heavily on .NET Framework- or Windows-specific functionality.</source>
          <target state="new">You may have some functionality in your library that's incompatible with .NET Core because it relies too heavily on .NET Framework- or Windows-specific functionality.</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Is it worth leaving that functionality behind for now and releasing a .NET Core version of your library with less features for the time being?</source>
          <target state="new">Is it worth leaving that functionality behind for now and releasing a .NET Core version of your library with less features for the time being?</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>b.</source>
          <target state="new">b.</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Would a refactor help here?</source>
          <target state="new">Would a refactor help here?</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Is it reasonable to write your own implementation of an unavailable .NET Framework API?</source>
          <target state="new">Is it reasonable to write your own implementation of an unavailable .NET Framework API?</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>You could consider instead copying, modifying, and using code from the <bpt id="p1">[</bpt>.NET Framework Reference Source<ept id="p1">](https://github.com/Microsoft/referencesource)</ept>.</source>
          <target state="new">You could consider instead copying, modifying, and using code from the <bpt id="p1">[</bpt>.NET Framework Reference Source<ept id="p1">](https://github.com/Microsoft/referencesource)</ept>.</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>It's licensed under the <bpt id="p1">[</bpt>MIT License<ept id="p1">](https://github.com/Microsoft/referencesource/blob/master/LICENSE.txt)</ept>, so you have significant freedom in doing this.</source>
          <target state="new">It's licensed under the <bpt id="p1">[</bpt>MIT License<ept id="p1">](https://github.com/Microsoft/referencesource/blob/master/LICENSE.txt)</ept>, so you have significant freedom in doing this.</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Just be sure to properly attribute Microsoft in your code!</source>
          <target state="new">Just be sure to properly attribute Microsoft in your code!</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Repeat this process as needed for different projects.</source>
          <target state="new">Repeat this process as needed for different projects.</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Once you have a plan, execute that plan.</source>
          <target state="new">Once you have a plan, execute that plan.</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The analysis phase could take some time depending on how large your codebase is.</source>
          <target state="new">The analysis phase could take some time depending on how large your codebase is.</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Spending time in this phase to thoroughly understand the scope of changes needed and to develop a plan can save you a lot of time in the long run, particularly if you have a more complex codebase.</source>
          <target state="new">Spending time in this phase to thoroughly understand the scope of changes needed and to develop a plan can save you a lot of time in the long run, particularly if you have a more complex codebase.</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Your plan could involve making significant changes to your codebase while still targeting .NET Framework 4.6.1, making this a more structured version of the previous approach.</source>
          <target state="new">Your plan could involve making significant changes to your codebase while still targeting .NET Framework 4.6.1, making this a more structured version of the previous approach.</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>How you go about executing your plan will be dependent on your codebase.</source>
          <target state="new">How you go about executing your plan will be dependent on your codebase.</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Mixing Approaches</source>
          <target state="new">Mixing Approaches</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>It's likely that you'll mix the above approaches on a per-project basis.</source>
          <target state="new">It's likely that you'll mix the above approaches on a per-project basis.</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>You should do what makes the most sense to you and for your codebase.</source>
          <target state="new">You should do what makes the most sense to you and for your codebase.</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Porting your Tests</source>
          <target state="new">Porting your Tests</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The best way to make sure everything works when you've ported your code is to test your code as you port it to .NET Core.</source>
          <target state="new">The best way to make sure everything works when you've ported your code is to test your code as you port it to .NET Core.</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>To do this, you'll need to use a testing framework that will build and run tests for .NET Core.</source>
          <target state="new">To do this, you'll need to use a testing framework that will build and run tests for .NET Core.</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Currently, you have three options:</source>
          <target state="new">Currently, you have three options:</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>xUnit</source>
          <target state="new">xUnit</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="new">Getting Started</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Tool to convert an MSTest project to xUnit</source>
          <target state="new">Tool to convert an MSTest project to xUnit</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>NUnit</source>
          <target state="new">NUnit</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="new">Getting Started</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Blog post about migrating from MSTest to NUnit</source>
          <target state="new">Blog post about migrating from MSTest to NUnit</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>MSTest</source>
          <target state="new">MSTest</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Recommended Approach to Porting</source>
          <target state="new">Recommended Approach to Porting</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Finally, porting the code itself!</source>
          <target state="new">Finally, porting the code itself!</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Ultimately, the actual porting effort will depend heavily on how your .NET Framework code is structured.</source>
          <target state="new">Ultimately, the actual porting effort will depend heavily on how your .NET Framework code is structured.</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>That being said, here is a recommended approach which may work well with your codebase.</source>
          <target state="new">That being said, here is a recommended approach which may work well with your codebase.</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>A good way to port your code is to begin with the "base" of your library.</source>
          <target state="new">A good way to port your code is to begin with the "base" of your library.</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>This may be data models or some other foundational classes and methods that everything else uses directly or indirectly.</source>
          <target state="new">This may be data models or some other foundational classes and methods that everything else uses directly or indirectly.</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Port the test project which tests the layer of your library that you're currently porting.</source>
          <target state="new">Port the test project which tests the layer of your library that you're currently porting.</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Copy over the "base" of your library into a new .NET Core project and select the version of the .NET Standard you wish to support.</source>
          <target state="new">Copy over the "base" of your library into a new .NET Core project and select the version of the .NET Standard you wish to support.</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Make any changes needed to get the code to compile.</source>
          <target state="new">Make any changes needed to get the code to compile.</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Much of this may require adding NuGet package dependencies to your <ph id="ph1">`project.json`</ph> file.</source>
          <target state="new">Much of this may require adding NuGet package dependencies to your <ph id="ph1">`project.json`</ph> file.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Run tests and make any needed adjustments.</source>
          <target state="new">Run tests and make any needed adjustments.</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Pick the next layer of code to port over and repeat steps 2 and 3!</source>
          <target state="new">Pick the next layer of code to port over and repeat steps 2 and 3!</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>If you methodically move outward from the base of your library and test each layer as needed, porting will be a systematic process where problems are isolated to one layer of code at a time.</source>
          <target state="new">If you methodically move outward from the base of your library and test each layer as needed, porting will be a systematic process where problems are isolated to one layer of code at a time.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>