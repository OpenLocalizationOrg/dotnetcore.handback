<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-442b6d0" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">991b4b8389cc967881c2c39d29c387687047489f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\collections\threadsafe\blockingcollection-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0b8f3b141db07e5106fbcac817b8f6f96351d030</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="new">BlockingCollection Overview</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="new">BlockingCollection Overview</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="new">.NET, .NET Core</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="new">BlockingCollection Overview</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> is a thread-safe collection class that provides the following features:</source>
          <target state="new"><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> is a thread-safe collection class that provides the following features:</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An implementation of the Producer-Consumer pattern.</source>
          <target state="new">An implementation of the Producer-Consumer pattern.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Thread-safe addition and removal of items from a collection.</source>
          <target state="new">Thread-safe addition and removal of items from a collection.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Optional maximum capacity.</source>
          <target state="new">Optional maximum capacity.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Insertion and removal operations that block when collection is empty or full.</source>
          <target state="new">Insertion and removal operations that block when collection is empty or full.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Insertion and removal "try" operations that do not block or that block up to a specified period of time.</source>
          <target state="new">Insertion and removal "try" operations that do not block or that block up to a specified period of time.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Encapsulates any collection type that implements <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.</source>
          <target state="new">Encapsulates any collection type that implements <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Cancellation with cancellation tokens.</source>
          <target state="new">Cancellation with cancellation tokens.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Two kinds of enumeration with <ph id="ph1">`foreach`</ph>:</source>
          <target state="new">Two kinds of enumeration with <ph id="ph1">`foreach`</ph>:</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Read-only enumeration.</source>
          <target state="new">Read-only enumeration.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Enumeration that removes items as they are enumerated.</source>
          <target state="new">Enumeration that removes items as they are enumerated.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Bounding and Blocking Support</source>
          <target state="new">Bounding and Blocking Support</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> supports bounding and blocking.</source>
          <target state="new"><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> supports bounding and blocking.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Bounding means you can set the maximum capacity of the collection.</source>
          <target state="new">Bounding means you can set the maximum capacity of the collection.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.</source>
          <target state="new">Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</source>
          <target state="new">Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</source>
          <target state="new">Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>A producing thread can call <ph id="ph1">`CompleteAdding`</ph> to indicate that no more items will be added.</source>
          <target state="new">A producing thread can call <ph id="ph1">`CompleteAdding`</ph> to indicate that no more items will be added.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consumers monitor the <ph id="ph1">`IsCompleted`</ph> property to know when the collection is empty and no more items will be added.</source>
          <target state="new">Consumers monitor the <ph id="ph1">`IsCompleted`</ph> property to know when the collection is empty and no more items will be added.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The following example shows a simple <ph id="ph1">`BlockingCollection`</ph> with a bounded capacity of 100.</source>
          <target state="new">The following example shows a simple <ph id="ph1">`BlockingCollection`</ph> with a bounded capacity of 100.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A producer task adds items to the collection as long as some external condition is true, and then calls <ph id="ph1">`CompleteAdding`</ph>.</source>
          <target state="new">A producer task adds items to the collection as long as some external condition is true, and then calls <ph id="ph1">`CompleteAdding`</ph>.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The consumer task takes items until the <ph id="ph1">`IsCompleted`</ph> property is true.</source>
          <target state="new">The consumer task takes items until the <ph id="ph1">`IsCompleted`</ph> property is true.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For a complete example, see <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</source>
          <target state="new">For a complete example, see <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Timed Blocking Operations</source>
          <target state="new">Timed Blocking Operations</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In timed blocking <ph id="ph1">`TryAdd`</ph> and <ph id="ph2">`TryTake`</ph> operations on bounded collections, the method tries to add or take an item.</source>
          <target state="new">In timed blocking <ph id="ph1">`TryAdd`</ph> and <ph id="ph2">`TryTake`</ph> operations on bounded collections, the method tries to add or take an item.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If an item is available it is placed into the variable that was passed in by reference, and the method returns <ph id="ph1">`true`</ph>.</source>
          <target state="new">If an item is available it is placed into the variable that was passed in by reference, and the method returns <ph id="ph1">`true`</ph>.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If no item is retrieved after a specified time-out period the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="new">If no item is retrieved after a specified time-out period the method returns <ph id="ph1">`false`</ph>.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The thread is then free to do some other useful work before trying again to access the collection.</source>
          <target state="new">The thread is then free to do some other useful work before trying again to access the collection.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For an example of timed blocking access, see the second example in <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</source>
          <target state="new">For an example of timed blocking access, see the second example in <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Cancelling Add and Take Operations</source>
          <target state="new">Cancelling Add and Take Operations</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Add and Take operations are typically performed in a loop.</source>
          <target state="new">Add and Take operations are typically performed in a loop.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can cancel a loop by passing in a <ph id="ph1">`CancellationToken`</ph> to the <ph id="ph2">`TryAdd`</ph> or <ph id="ph3">`TryTake`</ph> method, and then checking the value of the token's <ph id="ph4">`IsCancellationRequested`</ph> property on each iteration.</source>
          <target state="new">You can cancel a loop by passing in a <ph id="ph1">`CancellationToken`</ph> to the <ph id="ph2">`TryAdd`</ph> or <ph id="ph3">`TryTake`</ph> method, and then checking the value of the token's <ph id="ph4">`IsCancellationRequested`</ph> property on each iteration.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If the value is <ph id="ph1">`true`</ph>, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</source>
          <target state="new">If the value is <ph id="ph1">`true`</ph>, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following example shows an overload of <ph id="ph1">`TryAdd`</ph> that takes a cancellation token, and the code that uses it:</source>
          <target state="new">The following example shows an overload of <ph id="ph1">`TryAdd`</ph> that takes a cancellation token, and the code that uses it:</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Specifying the Collection Type</source>
          <target state="new">Specifying the Collection Type</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When you create a <ph id="ph1">`BlockingCollection&lt;T&gt;;`</ph>, you can specify not only the bounded capacity but also the type of collection to use.</source>
          <target state="new">When you create a <ph id="ph1">`BlockingCollection&lt;T&gt;;`</ph>, you can specify not only the bounded capacity but also the type of collection to use.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, you could specify a <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> for first in-first out (FIFO) behavior, or a <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> for last in-first out (LIFO) behavior.</source>
          <target state="new">For example, you could specify a <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> for first in-first out (FIFO) behavior, or a <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> for last in-first out (LIFO) behavior.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can use any collection class that implements the <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> interface.</source>
          <target state="new">You can use any collection class that implements the <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> interface.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The default collection type for <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> is <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph>.</source>
          <target state="new">The default collection type for <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> is <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph>.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following code example shows how to create a <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> of strings that has a capacity of 1000 and uses a <bpt id="p1">[</bpt>ConcurrentBag<ph id="ph2">&amp;lt;</ph>T<ph id="ph3">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept>:</source>
          <target state="new">The following code example shows how to create a <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> of strings that has a capacity of 1000 and uses a <bpt id="p1">[</bpt>ConcurrentBag<ph id="ph2">&amp;lt;</ph>T<ph id="ph3">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept>:</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>IEnumerable Support</source>
          <target state="new">IEnumerable Support</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>provides a <ph id="ph1">`GetConsumingEnumerable`</ph> method that enables consumers to use a <ph id="ph2">`foreach`</ph> statement to remove items until the collection is completed, which means it is empty and no more items will be added.</source>
          <target state="new">provides a <ph id="ph1">`GetConsumingEnumerable`</ph> method that enables consumers to use a <ph id="ph2">`foreach`</ph> statement to remove items until the collection is completed, which means it is empty and no more items will be added.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Use ForEach to Remove Items in a BlockingCollection<ept id="p1">](how-to-use-foreach-to-remove.md)</ept>.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>How to: Use ForEach to Remove Items in a BlockingCollection<ept id="p1">](how-to-use-foreach-to-remove.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Using Many BlockingCollections As One</source>
          <target state="new">Using Many BlockingCollections As One</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> and use the static methods such as <ph id="ph2">`TakeFromAny`</ph> and <ph id="ph3">`AddToAny`</ph> that will add to or take from any of the collections in the array.</source>
          <target state="new">For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> and use the static methods such as <ph id="ph2">`TakeFromAny`</ph> and <ph id="ph3">`AddToAny`</ph> that will add to or take from any of the collections in the array.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If one collection is blocking, the method immediately tries another until it finds one that can perform the operation.</source>
          <target state="new">If one collection is blocking, the method immediately tries another until it finds one that can perform the operation.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Use Arrays of Blocking Collections in a Pipeline<ept id="p1">](how-to-use-arrays-of-blockingcollections.md)</ept>.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>How to: Use Arrays of Blocking Collections in a Pipeline<ept id="p1">](how-to-use-arrays-of-blockingcollections.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="new">See Also</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>System.Collections.Concurrent</source>
          <target state="new">System.Collections.Concurrent</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Collections and Data Structures</source>
          <target state="new">Collections and Data Structures</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Thread-Safe Collections</source>
          <target state="new">Thread-Safe Collections</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>