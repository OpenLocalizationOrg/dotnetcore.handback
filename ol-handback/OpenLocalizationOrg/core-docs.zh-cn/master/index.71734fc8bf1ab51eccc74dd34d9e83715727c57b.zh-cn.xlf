<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-442b6d0" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">421d46585b5d83f5772fa6596ad581c8c6acbf71</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\collections\threadsafe\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">28847bd67e9aa21bdfb658a1113ce64eaf933788</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Thread-Safe Collections</source>
          <target state="new">Thread-Safe Collections</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Thread-Safe Collections</source>
          <target state="new">Thread-Safe Collections</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="new">.NET, .NET Core</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Thread-Safe Collections</source>
          <target state="new">Thread-Safe Collections</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept> namespace includes several collection classes that are both thread-safe and scalable.</source>
          <target state="new">The <bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept> namespace includes several collection classes that are both thread-safe and scalable.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</source>
          <target state="new">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>When you write new code, use the concurrent collection classes whenever the collection will be writing to multiple threads concurrently.</source>
          <target state="new">When you write new code, use the concurrent collection classes whenever the collection will be writing to multiple threads concurrently.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you are only reading from a shared collection, then you can use the classes in the <bpt id="p1">[</bpt>System.Collections.Generic<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic)</ept> namespace.</source>
          <target state="new">If you are only reading from a shared collection, then you can use the classes in the <bpt id="p1">[</bpt>System.Collections.Generic<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic)</ept> namespace.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>We recommend that you do not use <bpt id="p1">[</bpt>System.Collections<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections)</ept> collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</source>
          <target state="new">We recommend that you do not use <bpt id="p1">[</bpt>System.Collections<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections)</ept> collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Fine-Grained Locking and Lock-Free Mechanisms</source>
          <target state="new">Fine-Grained Locking and Lock-Free Mechanisms</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Some of the concurrent collection types use lightweight synchronization mechanisms such as <bpt id="p1">[</bpt>SpinLock<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Threading.SpinLock)</ept>, <bpt id="p2">[</bpt>SpinWait<ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Threading.SpinWait)</ept>, <bpt id="p3">[</bpt>SemaphoreSlim<ept id="p3">](https://docs.microsoft.com/dotnet/core/api/System.Threading.SemaphoreSlim)</ept>, and <bpt id="p4">[</bpt>CountdownEvent<ept id="p4">](https://docs.microsoft.com/dotnet/core/api/System.Threading.CountdownEvent)</ept>.</source>
          <target state="new">Some of the concurrent collection types use lightweight synchronization mechanisms such as <bpt id="p1">[</bpt>SpinLock<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Threading.SpinLock)</ept>, <bpt id="p2">[</bpt>SpinWait<ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Threading.SpinWait)</ept>, <bpt id="p3">[</bpt>SemaphoreSlim<ept id="p3">](https://docs.microsoft.com/dotnet/core/api/System.Threading.SemaphoreSlim)</ept>, and <bpt id="p4">[</bpt>CountdownEvent<ept id="p4">](https://docs.microsoft.com/dotnet/core/api/System.Threading.CountdownEvent)</ept>.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>These synchronization types typically use busy spinning for brief periods before they put the thread into a true <ph id="ph1">`Wait`</ph> state.</source>
          <target state="new">These synchronization types typically use busy spinning for brief periods before they put the thread into a true <ph id="ph1">`Wait`</ph> state.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</source>
          <target state="new">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</source>
          <target state="new">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> and <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> classes do not use locks at all.</source>
          <target state="new">The <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> and <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> classes do not use locks at all.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Instead, they rely on Interlocked operations to achieve thread-safety.</source>
          <target state="new">Instead, they rely on Interlocked operations to achieve thread-safety.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Because the concurrent collections classes support <bpt id="p1">[</bpt>ICollection<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.ICollection)</ept>, they provide implementations for the <ph id="ph1">`IsSynchronized`</ph> and <ph id="ph2">`SyncRoot`</ph> properties, even though these properties are irrelevant.</source>
          <target state="new">Because the concurrent collections classes support <bpt id="p1">[</bpt>ICollection<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.ICollection)</ept>, they provide implementations for the <ph id="ph1">`IsSynchronized`</ph> and <ph id="ph2">`SyncRoot`</ph> properties, even though these properties are irrelevant.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>always returns <ph id="ph1">`false`</ph> and <ph id="ph2">`SyncRoot`</ph> is always null.</source>
          <target state="new">always returns <ph id="ph1">`false`</ph> and <ph id="ph2">`SyncRoot`</ph> is always null.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The following table lists the collection types in the <bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept> namespace.</source>
          <target state="new">The following table lists the collection types in the <bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept> namespace.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="new">Type</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="new">Description</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>BlockingCollection<ph id="ph1">&amp;lt;</ph>T</source>
          <target state="new">BlockingCollection<ph id="ph1">&amp;lt;</ph>T</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Provides bounding and blocking functionality for any type that implements <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.</source>
          <target state="new">Provides bounding and blocking functionality for any type that implements <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>BlockingCollection Overview<ept id="p1">](blockingcollection-overview.md)</ept>.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>BlockingCollection Overview<ept id="p1">](blockingcollection-overview.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>ConcurrentBag<ph id="ph1">&amp;lt;</ph>T</source>
          <target state="new">ConcurrentBag<ph id="ph1">&amp;lt;</ph>T</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Thread-safe implementation of an unordered collection of elements.</source>
          <target state="new">Thread-safe implementation of an unordered collection of elements.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>ConcurrentDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue</source>
          <target state="new">ConcurrentDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Thread-safe implementation of a dictionary of key-value pairs.</source>
          <target state="new">Thread-safe implementation of a dictionary of key-value pairs.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T</source>
          <target state="new">ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Thread-safe implementation of a FIFO (first-in, first-out) queue.</source>
          <target state="new">Thread-safe implementation of a FIFO (first-in, first-out) queue.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>ConcurrentStack<ph id="ph1">&amp;lt;</ph>T</source>
          <target state="new">ConcurrentStack<ph id="ph1">&amp;lt;</ph>T</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Thread-safe implementation of a LIFO (last-in, first-out) stack.</source>
          <target state="new">Thread-safe implementation of a LIFO (last-in, first-out) stack.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T</source>
          <target state="new">IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The interface that a type must implement to be used in a <ph id="ph1">`BlockingCollection`</ph>.</source>
          <target state="new">The interface that a type must implement to be used in a <ph id="ph1">`BlockingCollection`</ph>.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Thread Synchronization in the .NET Framework version 1.0 and 2.0 Collections</source>
          <target state="new">Thread Synchronization in the .NET Framework version 1.0 and 2.0 Collections</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The collections first introduced in the .NET Framework version 1.0 are found in the <bpt id="p1">[</bpt>System.Collections<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections)</ept> namespace.</source>
          <target state="new">The collections first introduced in the .NET Framework version 1.0 are found in the <bpt id="p1">[</bpt>System.Collections<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections)</ept> namespace.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>These collections, which include the commonly used <bpt id="p1">[</bpt>ArrayList<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.ArrayList)</ept> and <bpt id="p2">[</bpt>Hashtable<ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Hashtable)</ept>, provide some thread-safety through the <ph id="ph1">`Synchronized`</ph> property, which returns a thread-safe wrapper around the collection.</source>
          <target state="new">These collections, which include the commonly used <bpt id="p1">[</bpt>ArrayList<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.ArrayList)</ept> and <bpt id="p2">[</bpt>Hashtable<ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Hashtable)</ept>, provide some thread-safety through the <ph id="ph1">`Synchronized`</ph> property, which returns a thread-safe wrapper around the collection.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The wrapper works by locking the entire collection on every add or remove operation.</source>
          <target state="new">The wrapper works by locking the entire collection on every add or remove operation.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</source>
          <target state="new">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This is not scalable and can cause significant performance degradation for large collections.</source>
          <target state="new">This is not scalable and can cause significant performance degradation for large collections.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Also, the design is not completely protected from race conditions.</source>
          <target state="new">Also, the design is not completely protected from race conditions.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The collection classes first introduced in the .NET Framework version 2.0 are found in the <bpt id="p1">[</bpt>System.Collections.Generic<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic)</ept> namespace.</source>
          <target state="new">The collection classes first introduced in the .NET Framework version 2.0 are found in the <bpt id="p1">[</bpt>System.Collections.Generic<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic)</ept> namespace.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>These include <bpt id="p1">[</bpt>List<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.List-1)</ept>, <bpt id="p2">[</bpt>Dictionary<ph id="ph3">&amp;lt;</ph>TKey, TValue<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2)</ept>, and so on.</source>
          <target state="new">These include <bpt id="p1">[</bpt>List<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.List-1)</ept>, <bpt id="p2">[</bpt>Dictionary<ph id="ph3">&amp;lt;</ph>TKey, TValue<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2)</ept>, and so on.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>These classes provide improved type safety and performance compared to the <ph id="ph1">`System.Collections`</ph> classes.</source>
          <target state="new">These classes provide improved type safety and performance compared to the <ph id="ph1">`System.Collections`</ph> classes.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">`System.Collections.Generic`</ph> collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</source>
          <target state="new">However, the <ph id="ph1">`System.Collections.Generic`</ph> collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>We recommend the <ph id="ph1">`System.Collections.Concurrent`</ph> collection classes because they provide not only the type safety of the <ph id="ph2">`System.Collections.Generic`</ph> collection classes, but also more efficient and more complete thread safety than the <ph id="ph3">`System.Collections`</ph> collections provide.</source>
          <target state="new">We recommend the <ph id="ph1">`System.Collections.Concurrent`</ph> collection classes because they provide not only the type safety of the <ph id="ph2">`System.Collections.Generic`</ph> collection classes, but also more efficient and more complete thread safety than the <ph id="ph3">`System.Collections`</ph> collections provide.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Related Topics</source>
          <target state="new">Related Topics</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="new">Title</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="new">Description</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="new">BlockingCollection Overview</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Describes the functionality provided by the <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> type.</source>
          <target state="new">Describes the functionality provided by the <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> type.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>When to Use a Thread-Safe Collection</source>
          <target state="new">When to Use a Thread-Safe Collection</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Explains when is it appropriate to use a thread-safe collection.</source>
          <target state="new">Explains when is it appropriate to use a thread-safe collection.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>How to: Add and Remove Items from a ConcurrentDictionary</source>
          <target state="new">How to: Add and Remove Items from a ConcurrentDictionary</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Describes how to add and remove elements from a <ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph>.</source>
          <target state="new">Describes how to add and remove elements from a <ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph>.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>How to: Add and Take Items Individually from a BlockingCollection</source>
          <target state="new">How to: Add and Take Items Individually from a BlockingCollection</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</source>
          <target state="new">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>How to: Add Bounding and Blocking Functionality to a Collection</source>
          <target state="new">How to: Add Bounding and Blocking Functionality to a Collection</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Describes how to use any collection class as the underlying storage mechanism for an <ph id="ph1">`IProducerConsumerCollection&lt;T&gt;;`</ph> collection.</source>
          <target state="new">Describes how to use any collection class as the underlying storage mechanism for an <ph id="ph1">`IProducerConsumerCollection&lt;T&gt;;`</ph> collection.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>How to: Use ForEach to Remove Items in a BlockingCollection</source>
          <target state="new">How to: Use ForEach to Remove Items in a BlockingCollection</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Describes how to use <ph id="ph1">`foreach`</ph> to remove all items in a blocking collection.</source>
          <target state="new">Describes how to use <ph id="ph1">`foreach`</ph> to remove all items in a blocking collection.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>How to: Use Arrays of Blocking Collections in a Pipeline</source>
          <target state="new">How to: Use Arrays of Blocking Collections in a Pipeline</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Describes how to use multiple blocking collections at the same time to implement a pipeline.</source>
          <target state="new">Describes how to use multiple blocking collections at the same time to implement a pipeline.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>How to: Create an Object Pool by Using a ConcurrentBag</source>
          <target state="new">How to: Create an Object Pool by Using a ConcurrentBag</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</source>
          <target state="new">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="new">Reference</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>System.Collections.Concurrent</source>
          <target state="new">System.Collections.Concurrent</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>