<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-442b6d0" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">652426127e693b117d749b4c5a126aecd230d43f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\expression-trees-building.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3822a891c5f2ce62dc906ee0e44071d866c5fcbb</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Building Expression Trees</source>
          <target state="new">Building Expression Trees</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Building Expression Trees</source>
          <target state="new">Building Expression Trees</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="new">.NET, .NET Core</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Building Expression Trees</source>
          <target state="new">Building Expression Trees</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Previous -- Interpreting Expressions</source>
          <target state="new">Previous -- Interpreting Expressions</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>All the expression trees you've seen so far have been created by the C# compiler.</source>
          <target state="new">All the expression trees you've seen so far have been created by the C# compiler.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>All you had to do was create a lambda expression that was assigned to a variable typed as an <ph id="ph1">`Expression&lt;Func&lt;T&gt;&gt;`</ph> or some similar type.</source>
          <target state="new">All you had to do was create a lambda expression that was assigned to a variable typed as an <ph id="ph1">`Expression&lt;Func&lt;T&gt;&gt;`</ph> or some similar type.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>That's not the only way to create an expression tree.</source>
          <target state="new">That's not the only way to create an expression tree.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For many scenarios you may find that you need to build an expression in memory at runtime.</source>
          <target state="new">For many scenarios you may find that you need to build an expression in memory at runtime.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Building Expression Trees is complicated by the fact that those expression trees are immutable.</source>
          <target state="new">Building Expression Trees is complicated by the fact that those expression trees are immutable.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Being immutable means that you must build the tree from the leaves up to the root.</source>
          <target state="new">Being immutable means that you must build the tree from the leaves up to the root.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The APIs you'll use to build expression trees reflect this fact: The methods you'll use to build a node take all its children as arguments.</source>
          <target state="new">The APIs you'll use to build expression trees reflect this fact: The methods you'll use to build a node take all its children as arguments.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Let's walk through a few examples to show you the techniques.</source>
          <target state="new">Let's walk through a few examples to show you the techniques.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Creating Nodes</source>
          <target state="new">Creating Nodes</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Let's start relatively simply again.</source>
          <target state="new">Let's start relatively simply again.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>We'll use the addition expression I've been working with throughout these sections:</source>
          <target state="new">We'll use the addition expression I've been working with throughout these sections:</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>To construct that expression tree, you must construct the leaf nodes.</source>
          <target state="new">To construct that expression tree, you must construct the leaf nodes.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The leaf nodes are constants, so you can use the <ph id="ph1">`Expression.Constant`</ph> method to create the nodes:</source>
          <target state="new">The leaf nodes are constants, so you can use the <ph id="ph1">`Expression.Constant`</ph> method to create the nodes:</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Next, you'll build the addition expression:</source>
          <target state="new">Next, you'll build the addition expression:</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Once you've got the addition expression, you can create the lambda expression:</source>
          <target state="new">Once you've got the addition expression, you can create the lambda expression:</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This is a very simple LambdaExpression, because it contains no arguments.</source>
          <target state="new">This is a very simple LambdaExpression, because it contains no arguments.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Later in this section, you'll see how to map arguments to parameters and build more complicated expressions.</source>
          <target state="new">Later in this section, you'll see how to map arguments to parameters and build more complicated expressions.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For expressions that are as simple as this one, you may combine all the calls into a single statement:</source>
          <target state="new">For expressions that are as simple as this one, you may combine all the calls into a single statement:</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Building a Tree</source>
          <target state="new">Building a Tree</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>That's the basics of building an expression tree in memory.</source>
          <target state="new">That's the basics of building an expression tree in memory.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>More complex trees generally mean more node types, and more nodes in the tree.</source>
          <target state="new">More complex trees generally mean more node types, and more nodes in the tree.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Let's run through one more example and show two more node types that you will typically build when you create expression trees: the argument nodes, and method call nodes.</source>
          <target state="new">Let's run through one more example and show two more node types that you will typically build when you create expression trees: the argument nodes, and method call nodes.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Let's build an expression tree to create this expression:</source>
          <target state="new">Let's build an expression tree to create this expression:</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>You'll start by creating parameter expressions for <ph id="ph1">`x`</ph> and <ph id="ph2">`y`</ph>:</source>
          <target state="new">You'll start by creating parameter expressions for <ph id="ph1">`x`</ph> and <ph id="ph2">`y`</ph>:</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Creating the multiplication and addition expressions follows the pattern you've already seen:</source>
          <target state="new">Creating the multiplication and addition expressions follows the pattern you've already seen:</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Next, you need to create a method call expression for the call to <ph id="ph1">`Math.Sqrt`</ph>.</source>
          <target state="new">Next, you need to create a method call expression for the call to <ph id="ph1">`Math.Sqrt`</ph>.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>And  then finally, you put the method call into a lambda expression, and make sure to define the arguments to the lambda expression:</source>
          <target state="new">And  then finally, you put the method call into a lambda expression, and make sure to define the arguments to the lambda expression:</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In this more complicated example, you see a couple more techniques that you will often need to create expression trees.</source>
          <target state="new">In this more complicated example, you see a couple more techniques that you will often need to create expression trees.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>First, you need to create the objects that represent parameters or local variables before you use them.</source>
          <target state="new">First, you need to create the objects that represent parameters or local variables before you use them.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Once you've created those objects, you can use them in your expression tree wherever you need.</source>
          <target state="new">Once you've created those objects, you can use them in your expression tree wherever you need.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Second, you need to use a subset of the Reflection APIs to create a <ph id="ph1">`MethodInfo`</ph> object so that you can create an expression tree to access that method.</source>
          <target state="new">Second, you need to use a subset of the Reflection APIs to create a <ph id="ph1">`MethodInfo`</ph> object so that you can create an expression tree to access that method.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You must limit yourself to the subset of the Reflection APIs that are available on the .NET Core platform.</source>
          <target state="new">You must limit yourself to the subset of the Reflection APIs that are available on the .NET Core platform.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Again, these techniques will extend to other expression trees.</source>
          <target state="new">Again, these techniques will extend to other expression trees.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Building Code In Depth</source>
          <target state="new">Building Code In Depth</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You aren't limited in what you can build using these APIs.</source>
          <target state="new">You aren't limited in what you can build using these APIs.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>However, the more complicated expression tree that you want to build, the more difficult the code is to manage and to read.</source>
          <target state="new">However, the more complicated expression tree that you want to build, the more difficult the code is to manage and to read.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Let's build an expression tree that is the equivalent of this code:</source>
          <target state="new">Let's build an expression tree that is the equivalent of this code:</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Notice above that I did not build the expression tree, but simply the delegate.</source>
          <target state="new">Notice above that I did not build the expression tree, but simply the delegate.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Using the <ph id="ph1">`Expression`</ph> class, you can't build statement lambdas.</source>
          <target state="new">Using the <ph id="ph1">`Expression`</ph> class, you can't build statement lambdas.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Here's the code that is required to build the same functionality.</source>
          <target state="new">Here's the code that is required to build the same functionality.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>It's complicated by the fact that there isn't an API to build a <ph id="ph1">`while`</ph> loop, instead you need to build a loop that contains a conditional test, and a label target to break out of the loop.</source>
          <target state="new">It's complicated by the fact that there isn't an API to build a <ph id="ph1">`while`</ph> loop, instead you need to build a loop that contains a conditional test, and a label target to break out of the loop.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The code to build the expression tree for the factorial function is quite a bit longer, more complicated, and it's riddled with labels and break statements and other elements we'd like to avoid in our everyday coding tasks.</source>
          <target state="new">The code to build the expression tree for the factorial function is quite a bit longer, more complicated, and it's riddled with labels and break statements and other elements we'd like to avoid in our everyday coding tasks.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For this section, I've also updated the visitor code to visit every node in this expression tree and write out information about the nodes that are created in this sample.</source>
          <target state="new">For this section, I've also updated the visitor code to visit every node in this expression tree and write out information about the nodes that are created in this sample.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>You can see the code in <bpt id="p1">[</bpt>the samples section<ept id="p1">](https://github.com/dotnet/core-docs/tree/master/samples/csharp-language/expression-trees)</ept>.</source>
          <target state="new">You can see the code in <bpt id="p1">[</bpt>the samples section<ept id="p1">](https://github.com/dotnet/core-docs/tree/master/samples/csharp-language/expression-trees)</ept>.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can experiment for yourself: build it and run the samples.</source>
          <target state="new">You can experiment for yourself: build it and run the samples.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Examining the APIs</source>
          <target state="new">Examining the APIs</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The expression tree APIs are some of the more difficult to navigate in .NET Core, but that's fine.</source>
          <target state="new">The expression tree APIs are some of the more difficult to navigate in .NET Core, but that's fine.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Their purpose is a rather complex undertaking: writing code that generates code at runtime.</source>
          <target state="new">Their purpose is a rather complex undertaking: writing code that generates code at runtime.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>They are necessarily complicated to provide a balance between supporting all the control structures available in the C# language and keeping the surface area of the APIs as small as reasonable.</source>
          <target state="new">They are necessarily complicated to provide a balance between supporting all the control structures available in the C# language and keeping the surface area of the APIs as small as reasonable.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This balance means that many control structures are represented not by their C# constructs, but by constructs that represent the underlying logic that the compiler generates from these higher level constructs.</source>
          <target state="new">This balance means that many control structures are represented not by their C# constructs, but by constructs that represent the underlying logic that the compiler generates from these higher level constructs.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Also, at this time, there are C# expressions that cannot be built directly using <ph id="ph1">`Expression`</ph> class methods.</source>
          <target state="new">Also, at this time, there are C# expressions that cannot be built directly using <ph id="ph1">`Expression`</ph> class methods.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In general, these will be the newest operators and expressions added in C# 5 and C# 6.</source>
          <target state="new">In general, these will be the newest operators and expressions added in C# 5 and C# 6.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>(For example, <ph id="ph1">`async`</ph> expressions cannot be built, and the new <ph id="ph2">`?.`</ph> operator cannot be directly created.)</source>
          <target state="new">(For example, <ph id="ph1">`async`</ph> expressions cannot be built, and the new <ph id="ph2">`?.`</ph> operator cannot be directly created.)</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Next -- Translating Expressions</source>
          <target state="new">Next -- Translating Expressions</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>