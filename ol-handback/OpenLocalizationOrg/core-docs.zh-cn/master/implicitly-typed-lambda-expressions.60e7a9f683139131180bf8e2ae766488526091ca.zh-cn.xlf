<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-442b6d0" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c43c1bd2ed95da0c3f8fc6061968e97671da43ee</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\implicitly-typed-lambda-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2cba03d099474c6975bc6cfdec943c50bbbffd0c</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Implicitly typed lambda expressions</source>
          <target state="new">Implicitly typed lambda expressions</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Implicitly typed lambda expressions</source>
          <target state="new">Implicitly typed lambda expressions</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="new">.NET, .NET Core</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Implicitly typed lambda expressions</source>
          <target state="new">Implicitly typed lambda expressions</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>I'm not using <ph id="ph1">`var`</ph> to declare this expression tree.</source>
          <target state="new">I'm not using <ph id="ph1">`var`</ph> to declare this expression tree.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can't use an implicitly typed variable declaration to declare a lambda expression.</source>
          <target state="new">You can't use an implicitly typed variable declaration to declare a lambda expression.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It creates a circular logic problem for the compiler.</source>
          <target state="new">It creates a circular logic problem for the compiler.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`var`</ph> declaration tells the compiler to figure out the type of the variable from the type of expression on the right hand side of the assignment operator.</source>
          <target state="new">The <ph id="ph1">`var`</ph> declaration tells the compiler to figure out the type of the variable from the type of expression on the right hand side of the assignment operator.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A lambda expression does not have a compile time type, but is convertible to any matching delegate or expression type.</source>
          <target state="new">A lambda expression does not have a compile time type, but is convertible to any matching delegate or expression type.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When you assign a lambda expression to a variable of a delegate or expression type, you tell the compiler to try and convert the lambda expression into an expression or delegate that matches the signature of the 'assigned to' variable.</source>
          <target state="new">When you assign a lambda expression to a variable of a delegate or expression type, you tell the compiler to try and convert the lambda expression into an expression or delegate that matches the signature of the 'assigned to' variable.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The compiler must try to make the thing on the right hand side of the assignment match the type on the left hand side of the assignment.</source>
          <target state="new">The compiler must try to make the thing on the right hand side of the assignment match the type on the left hand side of the assignment.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Both sides of the assignment can't be telling the compiler to look at the object on the other side of the assignment operator and see if my type matches.</source>
          <target state="new">Both sides of the assignment can't be telling the compiler to look at the object on the other side of the assignment operator and see if my type matches.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can get even more details on why the C# language specifies that behavior by reading <bpt id="p1">[</bpt>this article<ept id="p1">](http://download.microsoft.com/download/5/4/B/54B83DFE-D7AA-4155-9687-B0CF58FF65D7/type-inference.pdf)</ept> (PDF Download)</source>
          <target state="new">You can get even more details on why the C# language specifies that behavior by reading <bpt id="p1">[</bpt>this article<ept id="p1">](http://download.microsoft.com/download/5/4/B/54B83DFE-D7AA-4155-9687-B0CF58FF65D7/type-inference.pdf)</ept> (PDF Download)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>